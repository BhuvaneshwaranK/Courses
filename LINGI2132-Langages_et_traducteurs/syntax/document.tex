\documentclass{eplDoc}



\newcommand{\docType}	{Définition de la syntaxe}
\newcommand{\docDate}	{17/02/2012}
\newcommand{\docAuthor}	{Mulders Corentin, Forêt Nicolas, Pelsser François}
\newcommand{\courseCode}{LINGI2132}
\newcommand{\courseName}{Langages et traducteurs}
\usepackage{syntax}
\begin{document}
\maketitle
\newpage

\section{Syntax description}

\begin{grammar}
<identifier> ::= `a..z' \{ `a..z,A..Z,\_,0..9,'\} 

<class\_identifier> ::= `A..Z' \{ `a..z,A..Z,\_,0..9,'\} 

<tuple> ::= `{'`}' \alt `{' <element> \{`,' <element>\}`}'

<message> ::= `{'<identifier> \{`,' <element>\}`}'

<message\_sending> ::= <element> `<-' <message>

<boolean\_value> ::= true | false

<element> ::= <identifier> 
\alt<message\_sending>
\alt<instantiation>
\alt \{<digits>\}
\alt <boolean\_value>
\alt <operation>
\alt <message>
\alt <tuple>
\alt # | self | super

<operation> ::= <element> <binary\_operator> <element>
\alt <unary\_operator> <element>
\alt (<operation>)

<binary\_operator> ::= `+' | `-' | `*' | `/' | `\%' 
\alt `<=' | `=>' | `<' | `>' | `==' | `!=' 
\alt `and' | `or'

<unary\_operator> ::= ! | - 

<instantiation> ::= <class\_identifier> `<-' `{new' \{`,' <element>\}`}'


<assignment\_expression> ::= <identifier> `=' <element>

<statement> ::= <message\_sending> `;'
\alt <assignment\_expression> `;'
\alt return <element> `;'
\alt <while\_statement>
\alt <if\_statement>

<block code> ::= { <statement> }

<while\_statement> ::= `while' `(' <expression> `)'  `{'<block code>`}'

<if\_statement> ::= `if' `(' <expression> `)'  `{'<block code>`}'




<class> ::= `class' <class\_identifier> (extends <identifier>)? `{' <class body> `}'

<class\_body> ::= \{<attribute\_declaration>\} \{<message\_declaration>\}

<message\_declaration> ::= `def'  `{'<identifier> \{`,' <identifier>\}`}' `\{'<code\_block>`\}'

<attribute\_declaration> ::= <identifier> `;'









\end{grammar}


\section{Data types}

We would define some basic classes to store data. 

\begin{itemize}
	\item \textbf{Integer} represents real numbers. 
	\item \textbf{Boolean} represents a $<$boolean\_value$>$.
	\item \textbf{Tuple} represents a collection (a $<$tuple$>$ corresponds to a Tuple object).
	\item \textbf{Message} is a subclass of Tuple and represents a $<$message$>$.
	\item \textbf{Stdio} represents the standard input and output. 
\end{itemize}


\{digits\} is translated in Integer$\leftarrow$(new, \{digits\}) \\
4 + 2 is translated in Integer$\leftarrow$(new, 4)$\leftarrow$(add, Integer$\leftarrow$(new, 2)) \\
The operator 'not' is a unary operator. Example: Integer$\leftarrow$(new, 2)$\leftarrow$leq(4)$\leftarrow$(not). Syntactic sugar: !(2 $<=$ 4)\\

\begin{array}{|c|c|}
\hline
+ & add \\
- & minus \\
* & times \\
/ & div \\
and & and \\
or & or \\
<= & leq \\
>= & geq \\
== & eq \\
!= & neq \\
< & lt \\
> & gt \\
\% & mod \\
! & not \\
\hline
\end{array}



\section{Examples}

\begin{lstlisting}
class Point{
    x;
    y;

    def {new, px, py}
    {
        x = px;
        y = py;
    }

    def {add, px, py}
    {
        x = x + px;
        y = y + py;
    }

    def {getX}
    {
        return x;    
    }
    
    def {getY}
    {
        return y;    
    }

    def {gt, p2}
    {
        px = p2 <- getX;    
        py = p2 <- getY;    
        return (x*x + y*y) > (px*px + py*py)
    }
}

p = Point <- {new, 12, 14}
p2 = Point <- {new,13 ,28} + p

stdout <- {print, p > p2}

\end{lstlisting}
\end{document}
