// import the CP library
import cotfd;

int t0 = System.getCPUTime();


// create the CP Solver 
Solver<CP> cp();

string fString = System.getArgs()[2];

ifstream file(fString);

int nbEvents    = file.getInt();
int nbRooms     = file.getInt();
int nbFeatures  = file.getInt();
int nbStudents  = file.getInt();
int nbSlots     = 45;

range R     = 1..nbRooms;
range E     = 1..nbEvents;
range F     = 1..nbFeatures;
range S     = 1..nbStudents;
range T     = 1..nbSlots;

int roomsSizes[R];
int sAttends[S,E];
int rFeatures[R,F];
int eFeatures[E,F];

set{int} eventForRoom[R];
set{int} eventNotWhen[E];



int rNFeatures[R];

int eRoomSizeMin[E];
int roomsForEvent[E,R]=1;
int eTogether[E,E]=1;
int eNTogether[E]=0;

forall(r in R)
    roomsSizes[r] = file.getInt();

forall(s in S)
    forall(e in E)
        sAttends[s,e] = file.getInt();

forall(r in R)
    forall(f in F)
        rFeatures[r,f] = file.getInt();

forall(e in E)
    forall(f in F) 
         eFeatures[e,f] = file.getInt();

    


//END READ FILE

forall(e in E)
    eRoomSizeMin[e] = sum(s in S)(sAttends[s,e]);

forall(r in R)
{
    eventForRoom[r].insert(0);
    forall(e in E : eRoomSizeMin[e] <= roomsSizes[r])
    {
        boolean roomOk = true;
        forall(f in F)
            if(eFeatures[e,f] == 1 && rFeatures[r,f] != 1)
                roomOk = false;
        if(roomOk)
            eventForRoom[r].insert(e);
    }
}

forall(e1 in E,e2 in E: e2> e1)
{
    int i = 1;
    boolean endLoop = false;
    while(i<=nbStudents && !endLoop)
    {
        if((sAttends[i,e1] == 1) && (sAttends[i,e2] == 1))
        {
            eventNotWhen[e1].insert(e2);
            endLoop = true;
        }
        i++;
    }
}



var<CP>{int} eventAt[R,T](cp, 0..45);

//var<CP>{int} slotForEvent[E](cp, T);
//var<CP>{int} roomForEvent[E](cp, R);

forall(t in T, r in R)
{
    inSet(eventAt[r,t],eventForRoom[r]);
}


solve<cp>{
    

    //2 event that cannot be together aren't
    forall(e1 in E,r1 in R , r2 in R, t in T)
    {
        forall(e2 in eventNotWhen[e1])
            cp.post(!((eventAt[r1,t] == e1) && ((eventAt[r2,t] == e2))));
            //cp.post(all(t in T, r1 in R, r2 in R) (!((eventAt[r1,t] == e1) && ((eventAt[r2,t] == e2)))) ) ;  
    }


    //an event appends once and only once
 //   forall(e in E)
 //       cp.post((sum(t in T, r in R)(eventAt[r,t] == e))==1);
        
        
} using{
    forall(r in R) by (eventForRoom[r].getSize())
        forall (t in T: !eventAt[r,t].bound()) by (eventAt[r,t].getSize())
            tryall<cp>(e in E: eventAt[r,t].memberOf(e)) by (10000-eNTogether[e])
            {
                label(eventAt[r,t], e);
                cout << "#fail    = " << cp.getNFail() << endl;
            }
}

forall(t in T)
{
    cout << t << "\t\t";
    forall(r in R)
        cout << eventAt[r,t] << "  ";
    cout << endl; 
}

int t1 = System.getCPUTime();
cout << "time: " << t1 - t0 << endl;
cout << "#choices = " << cp.getNChoice() << endl;
cout << "#fail    = " << cp.getNFail() << endl;
