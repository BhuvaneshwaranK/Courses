\documentclass{eplDoc}



\newcommand{\docType}	{Assignment 4}
\newcommand{\docDate}	{20/04/2012}
\newcommand{\docAuthor}	{gr16 : Mulders Corentin, Pelsser Francois}
\newcommand{\courseCode}{LINGI2365}
\newcommand{\courseName}{Constraint programming}
\usepackage{syntax}

\lstset{breaklines=true, breakatwhitespace=false}

\begin{document}
\maketitle
\newpage

\section{The Brussels airport problem} %6pt

\subsection{Model implementation}
We modelized the problem in comet as a minimization problem with as variables the landing times of the planes and as constraints the fact that all landing times are different and that no landing occurs during a given period depending of the plane after a plane has landed : 
\begin{lstlisting}
range P         = 1..nbPlanes;

range T = (minPTime-maxdelay)..(maxPTime+maxdelay);

var<CP>{int} lTime[P](cp, T);               //actual landing time

minimize<cp>
    sum(p in P)(abs(lTime[p]-prefLTime[p])*delayCost[p])
subject to{
    forall(p1 in P)
    {
        cp.post(abs(lTime[p1] - prefLTime[p1])<maxdelay);
    }
    cp.post(alldifferent(lTime));
    forall(p1 in P, p2 in P: p1 != p2 && p1 > p2)
    {
        cp.post(!(lTime[p1] > lTime[p2]) || (lTime[p1] - lTime[p2]) > indispTime[p1]); 
        cp.post(cp.post(!(lTime[p2] > lTime[p1]) || (lTime[p2] - lTime[p1]) > indispTime[p2]));
    }
}
\end{lstlisting}
\subsection{3 different variable and/or value ordering heuristics}
In all of our three solutions we define a heuristic for ordering the access to the variables representing the planes landing times. The value ordering used for these times is the same in each solution and consist in considering the times closest to the plane's preffered landing time first. 
\subsubsection{First heuristic}
Our first heuristic orders the planes without a defined landing time by the cost of delaying their landing. Since we are dealing with an optimization problem this means that we are more likely to find non-optimal solutions first and those can then be discarded. \\  
Here is what we put in the using part of our comet program to use this heuristic : 
\begin{lstlisting}
forall (p in P: !lTime[p].bound()) by (delayCost[p])
                tryall<cp>(t in T: lTime[p].memberOf(t)) by (abs(t - prefLTime[p]))
                {
                    label(lTime[p], t);
                } 
\end{lstlisting}
\subsubsection{Second heuristic}
The second heuristic orders the planes by the time during which no other plane can land after them. This follows the same logic as the first heuristic as what seems to be more efficient would be to schedule the landing of the planes that cause the greatest loss of time first, which is the opposite. \\ 
Here is what we put in the using part of our comet program to use this heuristic : 
\begin{lstlisting}
forall (p in P: !lTime[p].bound()) by (indispTime[p])
                tryall<cp>(t in T: lTime[p].memberOf(t)) by (abs(t - prefLTime[p]))
                {
                    label(lTime[p], t);
                } 
\end{lstlisting}
\subsubsection{Third heuristic}
Our third heuristic tries to find a landing time for the planes for which the size of the remaining landing time variable domain is the smallest. This allow to reach a solution or a failure more quickly. \\ 
Here is what we put in the using part of our comet program to use this heuristic : 
\begin{lstlisting}
forall (p in P: !lTime[p].bound()) by (lTime[p].getSize())
                tryall<cp>(t in T: lTime[p].memberOf(t)) by (abs(t - prefLTime[p]))
                {
                    label(lTime[p], t);
                } 
\end{lstlisting}

\subsection{Meaningful criterias for comparing different search strategies}

\begin{itemize}
	\item The most basic criteria would simply to consider the execution time of each strategy on the same computer. This allows to roughly assess the quality of the search but we can't really trust it to be precise since the time could vary from one execution to another. 
	\item Another straightforward criteria would be the sum of the number of choices and the number of failures. Since the execution time is correlated with this value we would rather use this number of choices and failure instead since it's more reliable. 
	
\end{itemize}


\subsection{Heuristics comparison} % our heuristics + labelFF
Here are the results of the tests of our different heuristics on the brussels airport file. 
\begin{table}[h]
	\centering
		\begin{tabular}{|c|cccc|}
			\hline
			  & labelFF & first heuristic & second heuristic & third heuristic \\ 
			  \hline
			\#choices + \#fails &   236164 & 5475 & 896 & 206 \\ 
			time taken[ms] & 37846 & 1124 & 234 & 94 \\ 
			\hline
			
		\end{tabular}
\end{table}

All of our heuristic perform a lot better than labelFF but the second and third are particularly efficient. Especialy the third one.

\section{The Knapsack problem}
\subsection{A branch and bound approach} %5pt

\subsubsection{Model description}
In our model we use a boolean variable $x_i$ for each object to represent the fact that the object is placed in the sack or not. We then define the objective function as  $\sum_{i \in N} x_ia_i$ and post a constraint such as $\sum_{i \in N}x_iw_i \le b$. This corresponds to the following in comet : 
\begin{lstlisting}
var<CP>{int} objectsTaken[O](cp, 0..1);         

maximize<cp>
    sum(o in O)(objectsTaken[o]*oUsefullness[o])
subject to{
    cp.post(sum(o in O)(objectsTaken[o]*oWeight[o])<=knapsackCapacity);
}
\end{lstlisting}

\subsubsection{4 different heuristics for variable selection}
\begin{itemize}
	\item \textbf{First heuristic} \\ 
		Our first heuristic consist of starting with the most usefull objects. Then we try to take them in the sack. \\ 
		Here is what we put in the using part of our comet program to use this heuristic :
		\begin{lstlisting}
            forall (o in O: !objectsTaken[o].bound()) by (-oUsefullness[o])
                tryall<cp>(v in 0..1: objectsTaken[o].memberOf(v)) by (-v)
                {
                    label(objectsTaken[o], v);
                } 		\end{lstlisting}
	\item \textbf{Second heuristic} \\ 
		The second heuristic is based on the same idea as the first except now it choses objects that have the greatest $usefullness/weight$ ratio instead. This way we try to start by packing the objects that are both usefull and light first. \\ 
				Here is what we put in the using part of our comet program to use this heuristic :
		\begin{lstlisting}
		forall (o in O: !objectsTaken[o].bound()) by (-oUsefullness[o]/oWeight[o])
                tryall<cp>(v in 0..1: objectsTaken[o].memberOf(v)) by (-v)
                {
                    label(objectsTaken[o], v);
                } 
		\end{lstlisting}
	\item \textbf{Third heuristic} \\ 
				Here is what we put in the using part of our comet program to use this heuristic :
		\begin{lstlisting}
			%todo
		\end{lstlisting}
	\item \textbf{Fourth heuristic} \\ 
				Here is what we put in the using part of our comet program to use this heuristic :
		\begin{lstlisting}
			%todo
		\end{lstlisting}
	
\end{itemize}
\subsubsection{Heuristics tests} %also with labelFF

\subsection{Optimization over iterations} %5pt
\subsubsection{Which of the three points must be executed on which events ?}
\subsubsection{How is the value of ub modified to be sure to find the optimal solution ?}
\subsubsection{Why initialize ub with the upper bound ?}
\subsubsection{Experiments on knapsack-A and knapsack-B}


\subsection{Optimization via divide and conquer} %4pt
\subsubsection{Which of the four points must be executed on which events ?}
We know that the maximum is between 2 bounds.  We divide this bonded space in two and try to find if there is a solution in the part with the bigger values.  If there is no solution we are sure than the maximum we are looking after is in the half with smaller values so we have to update the upper bound (ii is in onCompletion).  If a solution is found, we are sure that the maximum we search is bigger or equal to this solution, so we update the lower bound (i is in onFeasibleSolution). We restart after each update (lb or ub) and we stop when we find a solution equals to the upper bound (we are sure that there cannot exist a bigger solution).\\
%We are using ceil instead of floor because we could be blocked with floor.  For instance if there is a solution at the objective function with the objective a and the solution we search is with objective a+1, we will find the solution with a and update lb to a, we will then still find the solution with objective a because the interval will be $\left[ \frac{a+a+1}2 ; a+1 \right]$ wich is equal to $\left[ a ; a+1 \right]$ so we are in an infinite loop.  If, instead, we set the 
\subsubsection{Experiments on knapsack-A, knapsack-B and knapsack-C}



\end{document}
